{# apps/dashboard/templates/dashboard/index.html #}
{% extends 'dashboard_base.html' %}

{% block content %}
<div class="container-fluid mt-4">
    <h1 class="mb-4">MLOps Dashboard</h1>

    <div class="row mb-4">
        <div class="col-lg-4 col-md-6 mb-3">
            <div class="card shadow-sm h-100">
                <div class="card-body">
                    <h5 class="card-title">모델 재학습 & 배포</h5>
                    <p class="card-text">모델 성능 저하 및 신규 데이터 유입 시 재학습을 트리거합니다.</p>
                    <form action="{{ url_for('dashboard.trigger_retrain') }}" method="post" class="d-inline mr-2">
                        <button type="submit" class="btn btn-warning btn-sm">모델 재학습</button>
                    </form>
                    <form action="{{ url_for('dashboard.deploy_model') }}" method="post" class="d-inline mr-2">
                        <button type="submit" class="btn btn-primary btn-sm">모델 배포</button>
                    </form>
                    <form action="{{ url_for('dashboard.rollback_model') }}" method="post" class="d-inline">
                        <button type="submit" class="btn btn-danger btn-sm">모델 롤백</button>
                    </form>
                </div>
            </div>
        </div>
        <div class="col-lg-8 col-md-6 mb-3">
            <div class="card shadow-sm h-100">
                <div class="card-body">
                    <h5 class="card-title">리소스 사용량 (더미)</h5>
                    <p class="card-text">현재 서버의 CPU 및 메모리 사용량을 모니터링합니다.</p>
                    <div class="row">
                        <div class="col-sm-6">
                            <h6 class="mb-0">CPU 사용량</h6>
                            <div class="progress" style="height: 20px;">
                                <div id="cpu_usage_bar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                            </div>
                        </div>
                        <div class="col-sm-6">
                            <h6 class="mb-0">메모리 사용량</h6>
                            <div class="progress" style="height: 20px;">
                                <div id="mem_usage_bar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h5 class="card-title">AI 모델 성능</h5>
                    <div class="row">
                        <div class="col-lg-3 col-md-4">
                            <div id="performance_metrics" class="p-2 border rounded bg-light">
                                <p><strong>Accuracy:</strong> <span id="accuracy_metric">...</span></p>
                                <p><strong>Precision:</strong> <span id="precision_metric">...</span></p>
                                <p><strong>Recall:</strong> <span id="recall_metric">...</span></p>
                                <p><strong>F1 Score:</strong> <span id="f1_score_metric">...</span></p>
                                <p><strong>Macro-AUC:</strong> <span id="macro_auc_metric">...</span></p>
                                <p><strong>Micro-AUC:</strong> <span id="micro_auc_metric">...</span></p>
                                <p><strong>Weighted-AUC:</strong> <span id="weighted_auc_metric">...</span></p>
                            </div>
                        </div>
                        <div class="col-lg-9 col-md-8">
                            <ul class="nav nav-tabs" id="performanceTab" role="tablist">
                                <li class="nav-item">
                                    <a class="nav-link active" id="roc-tab" data-toggle="tab" href="#roc" role="tab" aria-controls="roc" aria-selected="true">ROC Curve</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" id="pr-tab" data-toggle="tab" href="#pr" role="tab" aria-controls="pr" aria-selected="false">PR Curve</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" id="cm-tab" data-toggle="tab" href="#cm" role="tab" aria-controls="cm" aria-selected="false">Confusion Matrix</a>
                                </li>
                            </ul>
                            <div class="tab-content" id="performanceTabContent">
                                <div class="tab-pane fade show active" id="roc" role="tabpanel" aria-labelledby="roc-tab">
                                    <canvas id="rocChart" class="mt-3" style="max-height: 400px;"></canvas>
                                </div>
                                <div class="tab-pane fade" id="pr" role="tabpanel" aria-labelledby="pr-tab">
                                    <canvas id="prChart" class="mt-3" style="max-height: 400px;"></canvas>
                                </div>
                                <div class="tab-pane fade" id="cm" role="tabpanel" aria-labelledby="cm-tab">
                                    <div id="confusion_matrix_container" class="mt-3"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-md-6 mb-4">
            <div class="card shadow-sm h-100">
                <div class="card-body">
                    <h5 class="card-title">예측 결과 모니터링 (시간 추이)</h5>
                    <canvas id="predictionMonitorChart" style="max-height: 300px;"></canvas>
                </div>
            </div>
        </div>

        <div class="col-md-6 mb-4">
            <div class="card shadow-sm h-100">
                <div class="card-body">
                    <h5 class="card-title">이상 감지 알림</h5>
                    <div id="anomaly_alerts" class="list-group">
                        <div class="alert alert-info" role="alert">
                            이상 감지 데이터를 불러오는 중...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h5 class="card-title">데이터 드리프트 감지</h5>
                    <div id="drift_status" class="mb-3"></div>
                    <div id="drift_chart_container" class="row row-cols-1 row-cols-md-2 row-cols-lg-2 g-4">
                        </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>


<script>
    document.addEventListener('DOMContentLoaded', function() {
        // ... (이전 JavaScript 코드 유지) ...

        // --- 1. AI 모델 성능 시각화 ---
        async function fetchPerformanceData() {
            try {
                const response = await fetch("{{ url_for('dashboard.model_performance') }}");
                const data = await response.json();
                
                // 지표 업데이트
                document.getElementById('accuracy_metric').innerText = data.metrics.accuracy;
                document.getElementById('precision_metric').innerText = data.metrics.precision;
                document.getElementById('recall_metric').innerText = data.metrics.recall;
                document.getElementById('f1_score_metric').innerText = data.metrics.f1_score;

                // 새로운 AUC 지표 업데이트
                document.getElementById('macro_auc_metric').innerText = data.metrics.auc_roc_macro.toFixed(4);
                document.getElementById('micro_auc_metric').innerText = data.metrics.auc_roc_micro.toFixed(4);
                document.getElementById('weighted_auc_metric').innerText = data.metrics.auc_roc_weighted.toFixed(4);

                // ROC Curve
                const rocCtx = document.getElementById('rocChart').getContext('2d');
                const rocDatasets = [];
                for (const className in data.roc_data.fpr) {
                    const color = get_color_by_class(className);
                    rocDatasets.push({
                        label: `ROC (${className}) AUC: ${data.roc_data.auc[className].toFixed(2)}`,
                        data: data.roc_data.tpr[className].map((tpr, i) => ({x: data.roc_data.fpr[className][i], y: tpr})),
                        borderColor: color,
                        backgroundColor: color,
                        borderWidth: 2,
                        fill: false
                    });
                }
                new Chart(rocCtx, {
                    type: 'line',
                    data: { datasets: rocDatasets },
                    options: {
                        responsive: true,
                        aspectRatio: 1, // ROC 차트 비율을 1:1로 설정
                        scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: 'False Positive Rate' } }, y: { title: { display: true, text: 'True Positive Rate' } } }
                    }
                });

                // PR Curve
                const prCtx = document.getElementById('prChart').getContext('2d');
                const prDatasets = [];
                for (const className in data.pr_data.precision) {
                    const color = get_color_by_class(className);
                    prDatasets.push({
                        label: `PR (${className}) AUC: ${data.pr_data.auc[className].toFixed(2)}`,
                        data: data.pr_data.precision[className].map((precision, i) => ({x: data.pr_data.recall[className][i], y: precision})),
                        borderColor: color,
                        backgroundColor: color,
                        borderWidth: 2,
                        fill: false
                    });
                }
                new Chart(prCtx, {
                    type: 'line',
                    data: { datasets: prDatasets },
                    options: {
                        responsive: true,
                        aspectRatio: 1, // PR 차트 비율을 1:1로 설정
                        scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Recall' } }, y: { title: { display: true, text: 'Precision' } } }
                    }
                });

                // 혼동 행렬 테이블 생성
                const cmData = data.confusion_matrix;
                if (cmData && cmData.matrix.length > 0) {
                    const cmContainer = document.getElementById('confusion_matrix_container');
                    const table = document.createElement('table');
                    table.className = 'table table-bordered text-center';
                    
                    const thead = table.createTHead();
                    const headerRow = thead.insertRow();
                    headerRow.innerHTML = '<th></th>'; // 빈 좌측 상단 셀
                    cmData.labels.forEach(label => {
                        const th = document.createElement('th');
                        th.innerText = `예측: ${label}`;
                        headerRow.appendChild(th);
                    });
                    
                    const tbody = table.createTBody();
                    cmData.matrix.forEach((row, i) => {
                        const tr = tbody.insertRow();
                        const rowHeader = document.createElement('th');
                        rowHeader.innerText = `실제: ${cmData.labels[i]}`;
                        tr.appendChild(rowHeader);
                        row.forEach((cell, j) => {
                            const td = document.createElement('td');
                            td.innerText = cell;
                            if (i === j) {
                                td.classList.add('table-success'); // 정답인 경우 배경색
                            } else {
                                td.classList.add('table-danger'); // 오답인 경우 배경색
                            }
                            tr.appendChild(td);
                        });
                    });
                    
                    cmContainer.innerHTML = '';
                    cmContainer.appendChild(table);
                }

            } catch (error) {
                console.error("Error fetching performance data:", error);
                document.getElementById('performance_metrics').innerHTML = `<p class="text-danger">모델 성능 데이터를 불러오지 못했습니다.</p>`;
            }
        }

        // --- 2. 데이터 드리프트 시각화 ---
        async function fetchDataDriftData() {
            try {
                // Fetch API를 사용하여 JSON 데이터를 가져옵니다.
                const response = await fetch("{{ url_for('dashboard.data_drift') }}");
                // HTTP 상태 코드가 200 범위가 아닐 경우 에러 처리
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                const driftStatus = document.getElementById('drift_status');
                const driftChartContainer = document.getElementById('drift_chart_container');
                driftChartContainer.innerHTML = '';
                driftStatus.innerHTML = ''; // 상태 메시지 초기화
                
                let allFine = true;
                
                // 데이터 드리프트 감지 결과를 표시합니다.
                if (Object.keys(data.drift_results).length === 0) {
                     driftStatus.innerHTML = `<div class="alert alert-info py-1"><strong>데이터가 부족하여 드리프트를 감지할 수 없습니다.</strong></div>`;
                     return;
                }


                for (const feature in data.drift_results) {
                    const result = data.drift_results[feature];
                    
                    // Python에서 정수로 변환되었으므로 1인지 확인합니다.
                    const isDriftDetected = result.drift_detected === 1; 
                    
                    const alertClass = isDriftDetected ? 'alert-danger' : 'alert-success';
                    const message = `<strong>${feature}:</strong> ${result.message} (p-value: ${result.p_value})`;
                    driftStatus.innerHTML += `<div class="alert ${alertClass} py-1">${message}</div>`;
                    
                    if (isDriftDetected) {
                        allFine = false;
                    }
                }
                
                if (allFine && Object.keys(data.drift_results).length > 0) {
                     // 모든 특성이 정상일 경우 가장 상위에 종합 메시지를 추가
                     const allFineMessage = `<div class="alert alert-success py-1"><strong>모든 특성에서 데이터 드리프트가 감지되지 않았습니다.</strong></div>`;
                     driftStatus.innerHTML = allFineMessage + driftStatus.innerHTML;
                }

                // Plotly.js를 이용한 히스토그램 시각화 (type: 'histogram' 활용)
                const features = Object.keys(data.drift_data);
                if (features.length > 0) {
                    features.forEach(feature => {
                        // Bootstrap grid item (col)으로 감쌉니다.
                        const colDiv = document.createElement('div');
                        colDiv.className = 'col'; 

                        const plotDiv = document.createElement('div');
                        plotDiv.id = `drift_chart_${feature}`;
                        // Plotly 차트가 삽입될 div. 반응형을 위해 높이만 지정
                        plotDiv.style.height = '400px';    //350으로 상향
                        plotDiv.className = 'bg-white rounded-lg shadow p-2'; 
                        
                        colDiv.appendChild(plotDiv);
                        driftChartContainer.appendChild(colDiv);

                        const refData = data.drift_data[feature].reference;
                        const currData = data.drift_data[feature].current;

                        const traceRef = {
                            x: refData, // 원시 데이터 전달
                            name: '기준 데이터 (과거 30일)',
                            type: 'histogram', // Plotly.js에서 직접 빈을 계산
                            opacity: 0.6,
                            marker: { color: 'rgba(54, 162, 235, 1)' } // 파란색 계열
                        };
                        const traceCurr = {
                            x: currData, // 원시 데이터 전달
                            name: '최근 데이터 (최근 7일)',
                            type: 'histogram', // Plotly.js에서 직접 빈을 계산
                            opacity: 0.6,
                            marker: { color: 'rgba(255, 99, 132, 1)' } // 빨간색 계열
                        };

                        const layout = {
                            barmode: 'overlay', // 오버레이 모드로 겹쳐서 표시
                            title: `<b>${feature}</b> 분포 비교`,
                            xaxis: { 
                                title: feature,
                                automargin: true
                            },
                            yaxis: { 
                                title: '빈도',
                                automargin: true 
                            },
                            margin: { t: 30, r: 10, b: 70, l: 30 }, // 차트 여백 조정 b:70
                            responsive: true
                        };

                        Plotly.newPlot(plotDiv.id, [traceRef, traceCurr], layout);
                    });
                }
            } catch (error) {
                console.error("Error fetching drift data:", error);
                // 오류 메시지를 사용자에게 표시
                document.getElementById('drift_status').innerHTML = `<div class="alert alert-danger">데이터 드리프트 데이터를 불러오지 못했습니다. 서버 오류: ${error.message}</div>`;
            }
        }
        
        // --- 3. 예측 결과 모니터링 시각화 ---
        async function fetchPredictionMonitorData() {
            try {
                const response = await fetch("{{ url_for('dashboard.prediction_monitor') }}");
                const data = await response.json();
                
                const ctx = document.getElementById('predictionMonitorChart').getContext('2d');
                new Chart(ctx, {
                    type: 'line',
                    data: data.data,
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { position: 'top' },
                            title: { display: true, text: '시간에 따른 예측 결과 분포' }
                        },
                        scales: { x: { type: 'category' }, y: { stacked: true, title: { display: true, text: '예측 건수' } } }
                    }
                });
            } catch (error) {
                console.error("Error fetching prediction monitor data:", error);
                const container = document.getElementById('predictionMonitorChart').parentElement;
                container.innerHTML = `<div class="alert alert-danger">예측 모니터링 데이터를 불러오지 못했습니다.</div>`;
            }
        }

        // --- 4. 이상 감지 및 알림 ---
        async function fetchAnomalyData() {
            try {
                const response = await fetch("{{ url_for('dashboard.anomaly_detection') }}");
                const data = await response.json();
                
                const alertsContainer = document.getElementById('anomaly_alerts');
                alertsContainer.innerHTML = '';
                
                if (data.anomalies.length > 0) {
                    data.anomalies.forEach(anomaly => {
                        const alert = document.createElement('div');
                        alert.className = 'alert alert-danger py-2';
                        alert.innerHTML = `
                            <strong>이상 감지!</strong> ID: #${anomaly.id}<br>
                            특성: ${anomaly.features}<br>
                            예측: ${anomaly.predicted_class}
                        `;
                        alertsContainer.appendChild(alert);
                    });
                } else {
                    alertsContainer.innerHTML = `<div class="alert alert-success">최근 예측에서 이상 데이터가 감지되지 않았습니다.</div>`;
                }
            } catch (error) {
                console.error("Error fetching anomaly data:", error);
                document.getElementById('anomaly_alerts').innerHTML = `<div class="alert alert-warning">이상 감지 데이터를 불러오지 못했습니다.</div>`;
            }
        }

        // --- 5. 리소스 사용량 (더미) ---
        function updateResourceUsage() {
            const cpuUsage = Math.floor(Math.random() * 50) + 30; // 30-80%
            const memUsage = Math.floor(Math.random() * 40) + 50; // 50-90%
            
            const cpuBar = document.getElementById('cpu_usage_bar');
            cpuBar.style.width = cpuUsage + '%';
            cpuBar.innerText = cpuUsage + '%';
            
            const memBar = document.getElementById('mem_usage_bar');
            memBar.style.width = memUsage + '%';
            memBar.innerText = memUsage + '%';
        }

        // 초기 데이터 로딩 및 주기적 업데이트
        fetchPerformanceData();
        fetchDataDriftData();
        fetchPredictionMonitorData();
        fetchAnomalyData();
        updateResourceUsage();
        
        setInterval(updateResourceUsage, 5000);
    });

    function get_color_by_class(className) {
        const colors = {
            'setosa': 'rgb(255, 99, 132)',
            'versicolor': 'rgb(54, 162, 235)',
            'virginica': 'rgb(75, 192, 192)',
        };
        return colors[className] || 'rgb(128, 128, 128)';
    }
</script>
{% endblock %}